%\section{La gestione dei Widget}
%\label{se:prima-sezione}

%\section{La gestione delle camere di gioco}

%\section{L'implementazione del VR}

\section{Architettura Client - Server e la WebSocket}

Metarace è quindi un applicativo con struttura client-server e si collega al server con un canale di comunicazione bidirezionale basato sul protocollo WebSocket.
%
Questo protocollo è stato scelto per due motivi: il primo è che permette di tenere aperta una connessione tra client e server fino a che non viene terminata da uno dei due partecipanti; il secondo è che non è necessario definire il protocollo di comunicazione dato che si basa sul diffuso protocollo TCP.

Questo protocollo trasferisce i dati su una connessione full-duplex su singolo socket e permette l'invio e la ricezione di messaggi da parte di ambedue gli endpoint. 
%
Una connessione WebSocket è instaurata con un handshake specifico basato sul protocollo HTTP.
%
A seguito di questo handshake il protocollo di comunicazione cambia, e passa da HTTP a WebSocket tramite la connessione TCP utilizzata inizialmente. 

Unreal Engine fornisce supporto per l'utilizzo dei WebSocket tramite il modulo \textit{IWebSocket} \cite{UWebSocket}. Per poter utilizzare questo modulo bisogna aggiungere la dependency all'interno del file ".build.cs". Qui è mostrato il codice con l'aggiunta di tutte le dependencies utilizzate nel progetto:

\begin{lstlisting}[caption = Metarace.build.cs file]
using UnrealBuildTool;

public class Metarace : ModuleRules
{
	public Metarace(ReadOnlyTargetRules Target) : base(Target)
	{
		PublicDependencyModuleNames.AddRange(new[]
			{ "Core", "CoreUObject", "Engine", 
            "InputCore", "WebSockets", "Json", 
            "UMG", "HeadMountedDisplay", "CinematicCamera", 
            "Niagara" });
	}
}
\end{lstlisting}

La WebSocket viene creata all'interno di una classe astratta, chiamata \textit{BaseNetworkActor}.
%
Il motivo di questa scelta deriva dal fatto che Metarace non è l'unico applicativo dell'universo dell'azienda Ringmaster.
%
Con questa struttura è infatti possibile creare implementazioni diverse per ogni applicativo senza dover cambiare ogni volta il tipo di classe utilizzato.
%
Una classe astratta non viene instanziata ma viene ereditata da sottoclassi che ne implementano o ne sovrascrivono i metodi.
%
La scelta di una classe astratta invece di una interfaccia è dovuta dal fatto che ci sono implementazioni che devono essere uguali tra tutte le sottoclassi (l'intaurazione e il rilascio della connessione ad esempio).

Qui viene mostrato il codice di questa classe:

\begin{lstlisting}[caption = Sezione del file header di BaseNetworkActor dove vengono importati i moduli necessari alla WebSocket e viene definita la mappa degli eventi]
#include "WebSocketsModule.h" // Module definition
#include "IWebSocket.h"       // Socket definition

UCLASS()
class Metarace ABaseNetworkActor : public AActor
{
    GENERATED_BODY()
protected:
    TMap<int32, std::function<void(ABaseNetworkActor*, FJsonObject)>> 
        mEventMap;
\end{lstlisting}

Viene definita una \textit{TMap} per mappare tutte le funzioni che gestiscono gli eventi ricevuti dal server.
%
Questa mappa ha come key degli interi e come value delle funzioni di sola lettura, definite \textit{const}, che prendono come parametro un riferimento ad un'istanza della classe BaseNetworkActor o di una sua sottoclasse e un \textit{JsonObject}.
%
La comunicazione si baserà su messaggi di tipo Json, in Unreal Engine esistono gli oggetti di tipo JsonObject e definiti come \textit{FJsonObject}.
%
La mappa è un campo protetto perciò è stata implementata una funzione che esegue il \textit{put}, definita come segue:

\begin{lstlisting}[firstnumber=11, caption = Sezione del file header di BaseNetworkActor dove viene definita la funzione che esegue il put nella mappa degli eventi]
public:
    virtual void observeEvent(const int32 EventType,
        const std::function<void(ABaseNetworlActor*, 
        const FJsonObject&)>& iCallback);
    [...]  
}
\end{lstlisting}

Per creare la WebSocket chiamo la funzione \textit{CreateWebSocket} dal modulo:

\begin{lstlisting}[caption = Sezione del file source di ABaseNetworkActor dove viene creata la WebSocket]
void ABaseNetworkActor::Connect(const FString& Enpoint)
{
    const FString& WebsocketEndpoint = Endpoint;
    const FString& Protocol = TEXT("json");

	MSocket = FWebSocketsModule::Get().CreateWebSocket(WebsocketEndpoint, Protocol);
\end{lstlisting}

%
%
Definisco quindi tramite delle \textit{Lambda} gli eventi: \textit{OnConnected}, \textit{OnMessage}, \textit{OnClosed} e \textit{OnConnectionError}.

\begin{lstlisting}[firstnumber=7]
    MSocket->OnConnected().AddLambda(
		[=]() -> void
		{
			OnSocketConnected();
		}
	);
\end{lstlisting}

Il file \textit{Json} arriva sotto forma di stringa, perciò va inizializzato un \textit{TJsonReader} che la legge come file \textit{Json} e permette quindi di trasformarlo in un \textit{FJsonObject}.
%
Si noti che in queste implementazioni viene fatto uso di un oggetto della libreria \textit{Unreal Smart Pointer Library}, il puntatore smart \textit{TSharedPtr}.
%
Questa libreria è un'implementazione di Unreal in C++11 degli \textit{Smart Pointer} ideata per alleggerire il peso dell'allocazione e del tracciamento della memoria \cite{USmartPointerLibrary}.
%
Uno \textit{Shared Pointer} possiede l'oggetto a cui fa riferimento e gestisce la cancellazione dello stesso impedendola indefinitivamente oppure cancellandolo quando nessun puntatore vi fa più riferimento.

\begin{lstlisting}[firstnumber=13, caption=La funzione che gestisce i messaggi in entrata alla WebSocket]
	MSocket->OnMessage().AddLambda(
		[=](const FString& iMessage) -> void
		{
			const TSharedRef<TJsonReader<>> JSONReader = TJsonReaderFactory<>::Create(iMessage);

			if (TSharedPtr<FJsonObject> JSONObject; FJsonSerializer::Deserialize(JSONReader, JSONObject))
			{
				OnMessageReceived(JSONObject);
			}
		}
	);
\end{lstlisting}

Seguono quindi le \textit{Lambda Function} per la gestione degli eventi rimanenti:

\begin{lstlisting}[firstnumber=24, caption=Lambda function per la gestione della chiusura della connessione e dell'errore durante la connessione]
	MSocket->OnClosed().AddLambda(
		[=](int32 iStatusCode, const FString& iReason, bool iWasClean) -> void
		{
			UE_LOG(LogTemp, Display, TEXT("AHackathonBaseNetworkActor::BeginPlay::OnClosed message = %d %s %d"),
			       iStatusCode, *iReason, iWasClean);
		}
	);
	MSocket->OnConnectionError().AddLambda(
		[=](const FString& iError) -> void
		{
			UE_LOG(LogTemp, Display, TEXT("AHackathonBaseNetworkActor::BeginPlay::OnConnectionError error = %s"),
			       *iError);
		}
	);
\end{lstlisting}

E solo a questo punto si può connettere la WebSocket al server tramite la funzione \textit{Connect}. 
\begin{lstlisting}[firstnumber=38, caption = Connessione della WebSocket]
	MSocket->Connect();
}
\end{lstlisting}

La funzione che legge il file \textit{Json} e che cerca nella \textit{TMap} la funzione corrispondente cerca all'interno del file un campo "event" dove viene specificato l'intero corrispondente al value della funzione del client che il server vuole raggiungere:

\begin{lstlisting}[caption = funzione che gestisce la ricezione del messaggio in ABaseNetworkActor]
void ABaseNetworkActor::OnMessageReceived(const TSharedPtr<FJsonObject>& Message)
{
    if (Message.IsValid())
    {
        const FJsonObject& JSONObject = *(Message.Get());
        if (const int32 EventType = 
                JSONObject.GetIntegerField("event"); 
                mEventMap.Contains(EventType))
        {
            mEventMap[EventType](this, JSONObject);
        }
    }
}    
\end{lstlisting}

Infine, la funzione per inviare dati al server è definita come segue:

\begin{lstlisting}[caption = Funzione per inviare dati al server attraverso la WebSocket]
void ABaseNetworkActor::SendMessage(const FString& Message) const
{
    if (MSocket->IsConnected())
    {
        MSocket->Send(Message);
    }
}
\end{lstlisting}

    \subsection{Implementazione MetaraceNetworkActor}

    Dopo aver definito la classe astratta per la creazione e gestione della \textit{WebSocket} si passa a definire la sottoclasse che ne eredita le funzionalità: la classe \textit{MetaraceNetworkActor}.

    Questa classe si occupa di mappare i messaggi che arrivano dal server.
    %

    I delegates visti in precedenza (in \ref{alg:bindDelegate}) corrispondono a tutti gli eventi che \textit{MetaraceNetworkActor} deve gestire, vengono definiti nel file header nel modo che segue (in \ref{alg:instDelegate}). 
    %
    Per ogni messaggio in ingresso è stato inoltre creato un oggetto DTO per ospitare i dati contenuti nel Json dell'evento in questione, ed è proprio di questo tipo l'oggetto che il delegate passerà quando verrà eseguito:

\label{alg:instDelegate}
\begin{lstlisting}[caption = Dichiarazione delegate nel file header di MetaraceNetworkActor]
#include ...

DECLARE_DELEGATE_OneParam(FOnAvailableRacesFormatsEvent, const UAvailableRacesFormatsEventDTO*);
DECLARE_DELEGATE_OneParam(FOnPlayerJoinedEvent, const UPlayerJoinedEventDTO*);
DECLARE_DELEGATE_OneParam(FOnStartingGridEvent, const UStartingGridEventDTO*);
DECLARE_DELEGATE_OneParam(FOnAnotherPlayerJoinedEvent, const UAnotherPlayerJoinedEventDTO*);
DECLARE_DELEGATE_OneParam(FOnCountdownEvent, const UCountdownEventDTO*);
DECLARE_DELEGATE_OneParam(FOnRaceEvent, const URaceEventDTO*);
DECLARE_DELEGATE_OneParam(FOnLeaderboardEvent, const ULeaderboardEventDTO*);

UCLASS()
class Metarace AMetaraceNetworkActor : public ABaseNetworkActor
{
    GENERATED_BODY()

public:
    FOnLoginRequiredEvent OnLoginRequiredEventDelegate;
    FOnMetaraceConnectedEvent OnMetaraceConnectedEventDelegate;
    FOnAvailableRacesFormatsEvent 
        OnAvailableRacesFormatsEventDelegate;
    FOnPlayerJoinedEvent OnPlayerJoinedEventDelegate;
    FOnStartingGridEvent OnStartingGridEventDelegate;
    FOnAnotherPlayerJoinedEvent OnAnotherPlayerJoinedEventDelegate;
    FOnCountdownEvent OnCountdownEventDelegate;
    FOnRaceEvent OnRaceEventDelegate;
    FOnLeaderboardEvent OnLeaderboardEventDelegate;

    [...]
}
\end{lstlisting}

    %
    Verranno discussi nel dettaglio tutti gli eventi che sono stati implementati.

        \subsubsection{PlayEvent e AvailableRacesFormatsEvent}
        L'evento \textit{PlayEvent} viene innescato quando il giocatore preme il pulsante \textit{Start}.
        %
        Il client a questo punto invia al server il messaggio relativo all'intenzione del giocatore di voler iniziare una partita. 

        \begin{figure}[!ht]
            \centering
            \includegraphics[width=14.5cm]{figure/RacesFormats.png}
            \caption{Diagramma di sequenza per gli eventi GetAvailableRacesEvent e OnAvailableRacesFormatsEvent}
            \label{img:PlayEvent}
        \end{figure}

        \subsubsection{JoinEvent e PlayerJoinedEvent}

        \begin{figure}[!ht]
            \centering
            \includegraphics[width=13cm]{figure/JoinEvent.png}
            \caption{Diagramma di sequenza per gli eventi JoinEvent e PlayerJoinedEvent}
        \end{figure}

        \subsubsection{StartingGridEvent e AnotherPlayerJoinedEvent}

        \begin{figure}[!ht]
            \centering
            \includegraphics[width=10cm]{figure/StartingGrid.png}
            \caption{Diagramma di sequenza per gli eventi StartingGridEvent e AnotherPlayerJoinedEvent}
        \end{figure}

        \subsubsection{CountdownEvent e RaceEvent}

        \begin{figure}[!ht]
            \centering
            \includegraphics[width=11cm]{figure/CountdownEvent.png}
            \caption{Diagramma di sequenza per gli eventi CountdownEvent e RaceEvent}
        \end{figure}

        \subsubsection{RaceFinishedEvent e Leaderboardevent}

        \begin{figure}[!ht]
            \centering
            \includegraphics[width=12cm]{figure/RaceFinishedEvent.png}
            \caption{Diagramma di sequenza per gli eventi RaceFinishedEvent e LeaderboardEvent}
        \end{figure}


\section{Scelte di progetto guidate dalla flessibilità}

\section{Programmazione ad Eventi (EDP)}